# 密码学中的Hash 算法 #

上一篇文章里面，我们介绍了随机数以及随机数中的应用，可以看到密码学中到处都有随机数的身影，这种作为大部分密码学算法的基本组成被称之为 “加密基元“。今天我们一起来看一下另外一个加密基元 - 密码学Hash算法



## 什么是密码学Hash算法

密码学Hash算法是一个非常重要，而且常见的算法，是计算机密码学中的核心组成部分。密码学Hash算法是指将任何长度的二进制值映射成较短的固定长度二进制值的算法，这个较短的固定长度二进制值就是Hash值。先说一下：这个表述其实不是特别严谨，“任意长度”其实应该是 “算法允许长度范围内的任意长度”，因为有些密码学Hash算法是有输入长度限制的。既然很长的输入可以变成很短的输出，这就像我们写文章之后，需要写一个摘要一样，所以Hash值很多时候也叫做 “消息摘要”， Java中计算密码学Hash值的基类更是直接叫 MessageDigest.

下面代码能够更直观一点，我们来看一些密码学Hash的例子：

```java
  public static void main(String[] args) throws NoSuchAlgorithmException {
    System.out.println(md5("abcd") + " <- abcd");
    System.out.println(md5("abcd") + " <- abcd");
    System.out.println(md5("明月几时有，把酒问青天，不知天上宫阙，今夕是何年") + " <- 明月几时有，把酒问青天，不知天上宫阙，今夕是何年");
    System.out.println(md5("1") + " <- 1 ");
  }

  public static String md5(String content) throws NoSuchAlgorithmException {
    MessageDigest instance = MessageDigest.getInstance("MD5");
    instance.update(content.getBytes());
    return HexUtils.toHexString(instance.digest());
  }
```

输出结果为:

```shell
e2fc714c4727ee9395f324cd2e7f331f <- abcd
e2fc714c4727ee9395f324cd2e7f331f <- abcd
06d9a9f655c1ac1f0391e7dacfac6cbb <- 明月几时有，把酒问青天，不知天上宫阙，今夕是何年
c4ca4238a0b923820dcc509a6f75849b <- 1 
```



## 密码学Hash算法的特性

密码学Hash算法有好几个特性：

- 相同的输入消息总是能得到相同的Hash值。给定的Hash算法，不管消息长度多少，最终的Hash值长度是相同的。上面的例子可以看到 输入"abcd" 的MD5 Hash值一直都是`e2fc714c4727ee9395f324cd2e7f331f`
- 不可逆. 不可逆也叫单向性 (pre-image resistance)。 很难通过Hash值反推出原始消息是什么！设想一下，要是可逆的话，那么我们将10GB的文件变成一个128位的hash值，然后进行传输，对方接到后进行逆运算就可以得到原来的文件。那么我们的网络2G就够了，不用去争取5G,6G的了，大华为最近也就不用成天被灭总欺负了!
- 很难冲突。很难找到两个不同的消息能够产生相同的Hash值。这里用"很难" 而不是直接写“无冲突”是为了稍微严谨一点，因为Hash算法MD5已经在实践中产生碰撞了, 也就是攻击者不断地运算，能够找到两个不同的消息，使用MD5算出来的Hash值是一样的。

## 密码学Hash算法的分类

密码学Hash算法大致可以分为两个类别：普通的密码学Hash算法以及安全的密码学Hash算法。 前面列的几个密码学Hash算法的特性是所有Hash算法都具备的，不管是普通的还是安全的。而安全的密码学Hash算法则多了如下几个特性：

-  强抗碰撞 Collision Resistance

  如果两个不同的原文能产生相同的Hash，这个就是产生了Hash碰撞。而如果能随机地找到这两个原文M1, M2，使得h(M1) = h(M2), 那么这个就是强碰撞。而能抵抗这种碰撞的特性就叫 强抗碰撞。

- 弱抗碰撞 Second pre-image Resistance

  如果给定消息M1，能够找到M2，使得h(M1) = h(M2)，这个就是弱碰撞。而能抵抗这种碰撞的特性叫弱抗碰撞。

对于攻击者来说，Hash算法的破解难度为  强抗碰撞 < 弱抗碰撞 < 单向性。也就是说 首先破解的是 强抗碰撞，随便找，只要能找到两个不同的输入有相同的输出就算 破解了。这里的`破解` 也分为理论破解和实际破解， 一个Hash算法理论上产生了破解，不代表在实际使用场景中不能使用该算法，因为现实世界发生碰撞的可能性还是很大的。再退一步说，即使发生了实际破解，也不代表不能用，比如MD5 早就理论跟实际都破解了，但你如果只是用于内部系统进行消息完整性地校验，那应该可以大胆地用。

接下来我们来看几种常见的Hash算法：

### MD5

MD5 - Message Digest #5 是MIT教授1992年公开一种Hash算法，它接收任意长度的输入，输出一个128位的Hash值。这个算法其实挺佛性的：不管你来多大的输入，1位也行，100GB也行，我最终的输出有且仅有128位。可惜的是在2004年，这个算法被证明了产生碰撞。所以在一些安全要求比较高的场合下，慢慢地不再用MD5算法了。但是MD5还是出现在很多实现当中，因为它虽然打破了强碰撞性，但是单一性还是有的，而且它的输出是常见的Hash算法里面最短的，只有128位。

### 安全的Hash 算法 - SHA

## Java 中密码学Hash算法的使用



## 密码学Hash算法的使用场景

### 数据一致性： 文件比较，前后端分离架构的验证

### 身份验证： 密码保存与验证

文件秒传：



## Extentions:

### Hash算法 v.s 密码学的Hash算法

### 用Hash保存密码 带来的可能攻击







