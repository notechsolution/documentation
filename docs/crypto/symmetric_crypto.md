# 一文详解对称密钥加密

TL;DR: 前面几篇文章我们介绍了密码学的两大基本单元：随机数和Hash算法。有了这两大基元的加持，我们就可以开始密码学中的加解密算法的介绍。本文我们将重点介绍密码学中的对称密钥算法，包括算法的基本原理，各种对称算法的实现以及在Java中的实践。

## 数据加密及类型

数据加密，指的是根据一定规则，将数据处理成不规则的数据，使得人们除非有了关键的钥匙以及得知这个规则，难于得知无规则数据的真实含义。这个`一定规则` 就是加密算法，这个`钥匙`就是密钥。

数据加密分为对称密钥加密以及非对称密钥加密：

- 对称密钥加密： 双方共同持有这个密钥，发送方用这个密钥按照指定的算法将数据加密，再发出去；接收方用这个密钥将接收到的数据解密，以得到真实的数据含义。由于双方都持有这个密钥，而且内容相同，所以叫对称密钥
- 非对称密钥加密：这种加密方式的密钥是一对，发送方用其中的一把钥匙将数据加密，再发出去；接收方用这对密钥的另一把钥匙将数据解密，以得到真实的数据含义。发送方持有密钥中的一把钥匙，接收方持有另外一把。接收方持有的钥匙叫 `私钥`, 而接收方持有的这把钥匙叫`公钥` 。两把钥匙不一样，所以叫做非对称密钥加密，也叫做公开密钥算法。

这篇文章我们主要介绍对称密码加密算法。对称加密算法可以简单地概括为通过一个算法和一个密钥，对明文进行处理，变成一个无规则无意义数据的算法。明文在算法里面叫plaintext，密钥叫做key，而最终生成的密文叫ciphertext. 下图形象地描述了对称机密算法的操作：

![](D:\workspace\github\documentation\docs\crypto\image\symmetric.png)

我们也可以用如下的公式来简单表述对称加解密算法：

​					密文 = E（明文，算法，密钥）

​					明文 = D（密文，算法，密钥）



## 流密码算法

流密码加密是指将明文信息按字符（具体是按二进制位）逐位地加密的一类密码学算法。在计算机存储中，所有的信息最终都是用0和1进行表示。所有可以采用一定地算法，把某些0变成1，把某些1变成0，这样别人就很难知道真实的内容是什么。怎样把某些0变成1，把1变成0好呢？数学上的异或 XOR ⊕ 操作提供了极好的方案：

0 ⊕ 0 = 0
0 ⊕ 1 = 1
1 ⊕ 0 = 1
0 ⊕ 0 = 0

那么加密的时候，明文为M，密钥为K，这样加密的过程就是:  密文C = M ⊕ K, 而对应的解密过程则为 M = C ⊕ K, 因为 0 ⊕ 1 ⊕ 1= 0, 0 ⊕ 0 ⊕ 0= 0 . 所以破解者仅凭密文是很难破解出明文，即使采用一定的暴力手段，也无法确认破解的明文就是原始明文。

流密码算法的过程大概是这样的：

- 用户提供一个原始密钥key
- 算法将原始密钥key作为种子seed，生成一个伪随机数，这个伪随机数将作为加密的密码流。由于加解密双方知道算法以及种子seed，所以能生成相同的伪随机数
- 算法将原文M与密码流进行异或操作，从而得到密文C
- 信息的接受者同样根据密钥key以及约定的伪随机数生成算法, 生成一个密码流
- 接着将密文C与密码流进行异或操作，从而得出原文

流密码算法可以并行进行处理，而且主要是简单的异或操作，所以性能非常好。

#### 流密码算法的安全问题

但是流密码算法有个问题：如果原始key不变的话，之前的密文很容易被破解。比如有人用明文A，加密后得到的密文为EA。这时如果密钥不变，而我们拦截到密文EA， 那么我们怎样能破解密文呢？ 我们可以用明文B去加密，得到密文EB。这时我们手头上有对方的密文EA，我们自己明文B以及对应的密文EB，所以我们就可以推算出明文 A = EA  ⊕ EB  ⊕ B。 这个过程怎么推导出来的呢?

1. EA = A  ⊕ Key
2. EB = B  ⊕ Key

根据相同的值异或为0 这个规则，那么我们可以推出：

3. EA  ⊕ EB = A  ⊕ Key  ⊕  B  ⊕ Key  = A  ⊕ B  ⊕ (Key  ⊕ Key) = A  ⊕ B

这时两边同时异或B：

4. EA  ⊕ EB  ⊕ B = A  ⊕ B  ⊕ B = A  ⊕ (B  ⊕ B  ) = A 

所以明文A = EA  ⊕ EB  ⊕ B 

流密码算法的关键是一次性的密码本(One-time Pad), 这样才能确保消息不被破解。 由于速度快以及实现简单，在确保一次性密码的前提下，流密码算法一直活跃于各种业务场景下。RC4 (Rivest Cipher 4)就是一种常见的流密码加密算法的实现。之前一直用于HTTPS的TLS，对用户请求的内容进行对称加密，而其密钥则由RSA或者DH等密码协商算法一次性生成使用。 但有攻击者可以在4个小时破解一个HTTPS保护的cookie的内容。所以RC4现在基本被移除出 HTTPS的加密套件，在项目当中，大家也能不用就不能，下面要介绍块密码加密算法目前更为安全一点。



### 常见块密码加密算法



### DES / 3DES

#### AES

https://www.sohu.com/a/200488301_478315

https://blog.csdn.net/searchsun/article/details/2516191

https://blog.csdn.net/qq_28205153/article/details/55798628



### 补位标准

### 初始化向量 IV



## DES / 3DES / AES在Java中的实践



## 推荐使用

PRNG_AES_256_PCKS7

## Q&A

- 解密程序本身无法难于知道解密成功与否，除非补位出错
- 

