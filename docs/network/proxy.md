# 初探计算机网络代理

> TL;DR: 这篇文章介绍了计算机网络代理的简述，类型和使用场景。详解了正向代理, 反向代理的实现原理。最后介绍正向代理和反向代理的各种产品。

前段时间，由于项目需要在复杂的网络环境中运行，所以对计算机网络中的代理内容进行整理，以方便在团队内进行技术分享。分享是基于实际业务场景一层一层推演开来，所以不方便在外网直接引用，这里就采用课本常见的自上而下的介绍方式。

## 什么是计算机网络代理

维基百科中对计算机网络代理的定义是:

> In computer networking, a **proxy server** is a server application that acts as an intermediary between a client requesting a resource and the server providing that resource.

也就是计算机网络代理服务器 横亘在客户端与服务资源中间的一个服务, 该服务作为一个中介的形态，接收来自左手客户端的请求，然后向右边发起请求，最后将右边返回的内容转述给左边的客户端。下图简要地描述了以上的定义：

![Proxy Definition](.\image\proxy1.svg)



## 代理的类型有哪些

网络代理从面向的角度看看，可以分为两种代理: 正向代理和反向代理。

### 正向代理

正向代理是一个从内部向外部的更多资源获取数据的，面向互联网的代理服务。比如你想到谷歌上搜索一些技术问题，在目前的大多数网络中是无法直接打开谷歌的，于是需要一个代理帮你从现有的网络环境桥接到谷歌的网络，这个就是正向代理所做的事情。维基百科的下图描述了这一过程：

![](.\image\forward-proxy.svg)

### 反向代理

反向代理是指内部网络提供一个服务，用来对接互联网发来的连接请求，以达到控制和保护在内部网络中服务的目的。前面由内而外的称为正向代理，那么这种由外而内的也就称为了 反向代理。比如公司提供API服务的内部服务器有几十台，我们不想让外部客户知道内部的网络部署结构，所以可以在内部服务器前面搭设一个反向代理，外部客户只能调用这个反向代理的地址，再由反向代理传递给具体的内部服务器，这样既可以保护内部服务器的部署隐私，还可以控制外部客户的访问。同样，我们用维基百科的图来描述这一过程：

![](.\image\reverse-proxy.svg)

## 正向代理的实现原理是什么

正向代理的实现目前至少有三种不同的协议，一种是普通代理，一种是隧道代理，还有一种SOCKS协议。我们下面逐一进行介绍：

#### 普通代理

普通代理在[RFC 7230 - HTTP/1.1: Message Syntax and Routing](http://tools.ietf.org/html/rfc7230)的第五章第七小节做了简单的描述。这种代理扮演是*中间人*的角色，对于连接它的客户端来说，它是服务端；对于要连接的服务端来说，它是客户端。他就是在两端中间来回传送消息。

下面这张来自《HTTP权威指南》的图直观地描述了普通代理的实现：

![](.\image\simple-proxy.png)

这种普通代理的原理跟实现就很像是设计模式中的门面模式，都是左手交右手。

从上图可以看到，代理扮演中间人，左右交右手，那么也就意味着代理人可以看到传输的消息，这对于越来越强烈的隐私自由要求来说，除了一些公开的明文传输之外，其它的传输是很难接受中间人能截取消息的。

第二个问题，如果客户端是浏览器，请求的服务是HTTPS，那么浏览器会检验服务器发过来的证书和签名。但在普通代理模式中，客户端浏览器其实只跟了代理联系，压根就没有直接联系到服务器，所以没法直接拿到服务器的证书，即使代理拿到了也没用，因为代理没有服务器的私钥，没法生成签名，这样一来，浏览器就会出现证书和签名验证失败的情况。

虽然普通代理简单，但是遇到以上问题时，需要其它的代理方式来弥补这些不足。

#### 隧道代理

HTTP除了常见的GET，POST，PUT，PATCH，DELETE，HEAD等方法之外，在HTTP 1.1提出来一个叫CONNECT的方法，虽然它不是HTTP 1.1的核心规范，但却是一种得到广泛应用的扩展。客户端向服务端发起 HTTP CONNECT请求之后，客户端与服务端建立了一条TCP连接进行双向通信。扩展一下，假如这时的“服务端”是一个代理服务器，如果它在接收到客户端发起的HTTP CONNECT请求之后，与客户端建立了一条TCP连接，同时，它知道客户端真正要连接的服务端是谁，那么它可以与真正的服务端建立另外一个TCP连接，然后两个TCP对接起来，那不就能解决HTTPS的问题，同时中间人消息截取的问题也迎刃而解了。这种左手直接对接给右手的方式，就是隧道方式(Tunneling).

于是IETF的这篇文章[Tunneling TCP based protocols through Web proxy servers](https://tools.ietf.org/html/draft-luotonen-web-proxy-tunneling-01), 提出来用隧道方式实现代理服务器，以传输所有基于TCP的协议。《HTTP权威指南》里面的这张图对这个过程做了详细的说明：

![](.\image\tunnel-proxy.png)



> 假如我通过代理访问 A 网站，浏览器首先通过 CONNECT 请求，让代理创建一条到 A 网站的 TCP 连接；一旦 TCP 连接建好，代理无脑转发后续流量即可。所以这种代理，理论上适用于任意基于 TCP 的应用层协议，HTTPS 网站使用的 TLS 协议当然也可以。这也是这种代理为什么被称为隧道的原因。对于 HTTPS 来说，客户端透过代理直接跟服务端进行 TLS 握手协商密钥，所以依然是安全的，

隧道代理完美地解决了普通代理模式中的明文传输问题，以及HTTPS的证书验证问题。

但键盘侠可能还会有问题，比如 我的协议是基于TCP的，直接在第五层的协议,比如直接到Socket连接，按照OSI七层模式的定义，我是不能倒回去调用第七层的HTTP CONNECT的方法的，这样违反了规定。或者我的协议是在第七层，但是我不想通过同样是第七层的HTTP CONNECT进行代理，因为我感觉它性能会损失一下。

![](D:\workspace\github\documentation\docs\network\image\osi7.png)

>  只要合理合法合规，键盘侠的问题也是要解决的！

#### SOCKS 协议

SOCKS协议其实是互联网发展很早很早的时候就提出来的。90年代初，随着互联网的发展，网络攻击也随着而来，广大群众绞尽脑汁，想出了很多办法，但归根结底这些办法都是尽量减少内网服务器向公网暴露的机会，也就是至今仍为广大DevOps领导奉若神谕的“最小原则”: 如果没有强烈要求，就不进行授权。从而提高安全性。后来，有个叫David的老哥想出了一套 代理防火墙的解决方案，在客户端提供了一套类库，同时在防火墙服务器上部署一个服务器端，通过简单的配置就可以完成应用层的过滤，允许和拒绝哪些端口被接入，而且非常容易维护，这套解决方案就叫做SOCKS。后来一个姓李的哥们，对，赵钱孙李的李哥!  把SOCKS提炼出来，发展成一种协议，在服务器上提供TCP的转发，允许用户可以透明的穿透防火墙的阻拦。(呃，这里省去千八百字)

下图对于SOCKS的工作过程做了一个详细的说明：

![](D:\workspace\github\documentation\docs\network\image\socks.png)



SOCKS是在OSI的第五层，也就是Socket上进行的，所以能支持大部分常用的网络协议，比如HTTP/HTTPS, FTP, SMTP 等。

SOCKS常见的版本有v4跟v5，其中v5比v4多了用户验证，支持UDP等功能，目前已经成为SOCKS的主流版本。

### 反向代理的实现原理是什么

反向代理在开发过程当中其实用得不多，只有当需要做负载均衡，路径跳转时才会用到。它的实验原理也大致可以理解为 类似于规则引擎。当请求的URL是满足规则1，则自动跳转到1 指定的内部服务器地址。如下图：

![](.\image\reverse-proxy-2.png)

下面是一个反向代理配置的例子：

```
location  /abc
    {
        proxy_pass http://10.13.6.8:83/;
        proxy_set_header Host   $host;
        proxy_set_header X-Real-IP      $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }
 
location  /edf
    {
        proxy_pass http://10.13.6.9:83;
        proxy_set_header Host   $host;
        proxy_set_header X-Real-IP      $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }
```

反向代理看起来比较简单，这里就不过多展开介绍他的实现过程。



## 都有哪些代理产品

- 正向代理的产品有很多：
  - 基于HTTP CONNECT的 Squid (也可以支持SOCKS，但同时只能支持一种，且需要重编译才可以用)，更多的是企业环境使用
  - 基于SOCKS的一大堆客户端跟服务端的产品，更多的是个人使用
- 反向代理的产品：
  - Nginx
  - Apache的web server
  - HAProxy